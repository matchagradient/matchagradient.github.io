<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon.png">
    <script src="/assets/js/script.js" defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lyapunov Fractal Explorer</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
</head>
<body class="fractal-page">
    <svg class="cube-background" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice">
        <g id="cubeContainer"></g>
    </svg>
    <nav>
        <div class="nav-container">
            <div class="logo"><a href="/index.html">Mike Wang</a></div>
            <ul class="nav-links external-links">
                <li><a href="/collections.html">Collections</a></li>
            </ul>
        </div>
    </nav>
    
    <div class="interactive-section interactive-section">
        <canvas id="canvas"></canvas>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span>Rendering...</span>
        </div>
        <div class="controls">
            <h2>Lyapunov Fractal Explorer</h2>
            
            <div class="direction-controls">
                <div></div>
                <button class="direction-btn" data-direction="up">↑</button>
                <div></div>
                <button class="direction-btn" data-direction="left">←</button>
                <button class="direction-btn center" data-direction="reset">⌂</button>
                <button class="direction-btn" data-direction="right">→</button>
                <div></div>
                <button class="direction-btn" data-direction="down">↓</button>
                <div></div>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn">Zoom In</button>
                <button class="zoom-btn" id="zoomOut">Zoom Out</button>
            </div>
            <button class="reset-btn" id="resetView">Reset View</button>
            <div class="sequence-controls">
                <label for="sequencePattern">Sequence Pattern</label>
                <select id="sequencePattern">
                    <option value="ab">ab</option>
                    <option value="aab">aab</option>
                    <option value="abb">abb</option>
                    <option value="aba">aba</option>
                    <option value="aabb">aabb</option>
                    <option value="abab">abab</option>
                    <option value="aabbb">aabbb</option>
                    <option value="aaab">aaab</option>
                </select>
                <div class="sequence-help">Pattern alternates between 'a' and 'b' parameters</div>
            </div>
            <div class="locations">
                <label for="locationSelect">Interesting Locations</label>
                <select id="locationSelect">
                    <option value="">Select a location...</option>
                    <option value="default">Default View</option>
                    <option value="chaos">Chaos Region</option>
                    <option value="stability">Stability Island</option>
                    <option value="transition">Transition Zone</option>
                    <option value="spiral">Spiral Pattern</option>
                    <option value="bifurcation">Bifurcation Point</option>
                </select>
            </div>
            <div class="color-scheme">
                <label for="colorScheme">Color Scheme</label>
                <select id="colorScheme">
                    <option value="classic">Classic</option>
                    <option value="fire">Fire</option>
                    <option value="ocean">Ocean</option>
                    <option value="psychedelic">Psychedelic</option>
                    <option value="grayscale">Grayscale</option>
                </select>
            </div>
            <div class="performance-controls">
                <label for="quality">Quality vs Performance</label>
                <input type="range" id="quality" class="quality-slider" min="1" max="5" value="3">
                <div class="quality-labels">
                    <span>Fast</span>
                    <span>Balanced</span>
                    <span>High Quality</span>
                </div>
            </div>
            <div class="export-section">
                <button class="export-btn" id="exportBtn">Export as Image</button>
            </div>
            <div class="info">
                <div class="info-item">
                    <span class="info-label">Zoom:</span> <span id="zoomLevel">1.0x</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Center:</span> <span id="centerCoords">(2.5, 2.5)</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Iterations:</span> <span id="iterations">100</span>
                </div>
            </div>
        </div>
        <div class="notification" id="notification"></div>
    </div>
    
    <div class="content-section">
        <h1>Exploring Lyapunov Fractals</h1>
        <p>
            <a href="https://en.wikipedia.org/wiki/Lyapunov_fractal">Lyapunov fractal</a>
            are a fascinating class of mathematical objects that visualize the stability of dynamic systems. 
            Named after the Russian mathematician Aleksandr Lyapunov, these fractals are generated by calculating the 
            <span class="highlight">Lyapunov exponent</span> for each point in a parameter space.
        </p>
        <p>
            The interactive explorer above allows you to navigate through the complex landscape of the Lyapunov fractal. 
            Each color represents a different level of stability in the system - blue regions indicate stability, while 
            red regions represent chaos. The patterns you see emerge from the simple mathematical rules governing 
            the system's behavior.
        </p>
        
        <h2>Understanding the Mathematics</h2>
        <p>
            The Lyapunov exponent measures the rate of divergence of infinitesimally close trajectories in a dynamic system. 
            A negative exponent indicates stability (trajectories converge), while a positive exponent indicates chaos 
            (trajectories diverge exponentially).
        </p>
        <p>
            In this visualization, we're exploring the logistic map with alternating parameters. The sequence pattern 
            (like "ab" or "aab") determines how the parameters alternate during the calculation. This creates the 
            intricate patterns and structures you see in the fractal.
        </p>
        
        <h2>Features of the Explorer</h2>
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Interactive Navigation</h3>
                <p>Click and drag to pan around the fractal, use the zoom controls or mouse wheel to explore details at different scales.</p>
            </div>
            <div class="feature-card">
                <h3>Sequence Patterns</h3>
                <p>Experiment with different sequence patterns to see how they affect the fractal's structure and appearance.</p>
            </div>
            <div class="feature-card">
                <h3>Interesting Locations</h3>
                <p>Jump to predefined locations that showcase particularly interesting features of the fractal landscape.</p>
            </div>
            <div class="feature-card">
                <h3>Color Schemes</h3>
                <p>Choose from various color schemes to highlight different aspects of the fractal's structure.</p>
            </div>
            <div class="feature-card">
                <h3>Quality Control</h3>
                <p>Adjust the quality-performance balance to suit your device's capabilities and your need for detail.</p>
            </div>
            <div class="feature-card">
                <h3>Export Images</h3>
                <p>Capture your favorite views of the fractal as high-quality images for further study or sharing.</p>
            </div>
        </div>
        
        <h2>The Beauty of Chaos</h2>
        <p>
            Lyapunov fractals exemplify the principle of "order in chaos" - complex, beautiful structures emerging from 
            simple deterministic rules. As you explore, you'll notice self-similar patterns at different scales, 
            intricate boundaries between stability and chaos, and regions of startling complexity.
        </p>
        <p>
            These fractals aren't just visually stunning; they also have practical applications in fields ranging from 
            physics and biology to economics and engineering, helping us understand complex systems and predict their behavior.
        </p>
    </div>
    
    <script>
        class LyapunovExplorer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.notification = document.getElementById('notification');
                
                // View parameters
                this.centerX = 2.5;
                this.centerY = 2.5;
                this.zoom = 1;
                this.baseMaxIterations = 100;
                this.maxIterations = this.baseMaxIterations;
                this.colorScheme = 'classic';
                this.sequencePattern = 'ab';
                
                // Performance settings
                this.qualityLevel = 3; // 1-5 (fast to high quality)
                this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
                this.tileSize = 64; // Size of tiles for progressive rendering
                
                // Interaction state
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                // Rendering state
                this.renderQueue = [];
                this.isRendering = false;
                this.cancelRender = false;
                this.visibleTiles = new Set();
                
                // Cache for previously computed tiles
                this.tileCache = new Map();
                
                // Interesting locations
                this.interestingLocations = {
                    default: { name: "Default View", x: 2.5, y: 2.5, zoom: 1 },
                    chaos: { name: "Chaos Region", x: 3.2, y: 3.2, zoom: 2 },
                    stability: { name: "Stability Island", x: 2.0, y: 3.5, zoom: 3 },
                    transition: { name: "Transition Zone", x: 2.8, y: 2.2, zoom: 2.5 },
                    spiral: { name: "Spiral Pattern", x: 3.5, y: 2.8, zoom: 4 },
                    bifurcation: { name: "Bifurcation Point", x: 3.0, y: 3.0, zoom: 5 }
                };
                
                this.init();
            }
            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.render();
                
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.render();
                });
            }
            resizeCanvas() {
                // Set canvas size to match container
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                // Clear cache when resizing
                this.tileCache.clear();
            }
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.startDrag(e));
                this.canvas.addEventListener('mousemove', (e) => this.drag(e));
                this.canvas.addEventListener('mouseup', () => this.endDrag());
                this.canvas.addEventListener('mouseleave', () => this.endDrag());
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.startDrag(e.touches[0]));
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.drag(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', () => this.endDrag());
                
                // Wheel zoom
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoomAt(e.clientX, e.clientY, delta);
                });
                
                // Direction controls
                document.querySelectorAll('.direction-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const direction = btn.dataset.direction;
                        if (direction === 'reset') {
                            this.resetView();
                        } else {
                            this.pan(direction);
                        }
                    });
                });
                
                // Zoom buttons
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 1.5);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 0.67);
                });
                
                // Reset view
                document.getElementById('resetView').addEventListener('click', () => {
                    this.resetView();
                });
                
                // Sequence pattern
                document.getElementById('sequencePattern').addEventListener('change', (e) => {
                    this.sequencePattern = e.target.value;
                    this.clearCache();
                    this.render();
                });
                
                // Location selector
                document.getElementById('locationSelect').addEventListener('change', (e) => {
                    const locationKey = e.target.value;
                    if (locationKey && this.interestingLocations[locationKey]) {
                        this.navigateToLocation(this.interestingLocations[locationKey]);
                        e.target.value = ''; // Reset selector
                    }
                });
                
                // Color scheme
                document.getElementById('colorScheme').addEventListener('change', (e) => {
                    this.colorScheme = e.target.value;
                    this.clearCache();
                    this.render();
                });
                
                // Quality slider
                document.getElementById('quality').addEventListener('input', (e) => {
                    this.qualityLevel = parseInt(e.target.value);
                    this.updateMaxIterations();
                    this.clearCache();
                    this.render();
                });
                
                // Export button
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportImage();
                });
            }
            startDrag(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
            }
            drag(e) {
                if (!this.isDragging) return;
                
                const dx = e.clientX - this.lastX;
                const dy = e.clientY - this.lastY;
                
                const scale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                this.centerX -= dx * scale;
                this.centerY -= dy * scale;
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                this.updateInfo();
                this.scheduleRender();
            }
            endDrag() {
                this.isDragging = false;
            }
            pan(direction) {
                const moveAmount = 0.5 / this.zoom;
                
                switch(direction) {
                    case 'up':
                        this.centerY -= moveAmount;
                        break;
                    case 'down':
                        this.centerY += moveAmount;
                        break;
                    case 'left':
                        this.centerX -= moveAmount;
                        break;
                    case 'right':
                        this.centerX += moveAmount;
                        break;
                }
                
                this.updateInfo();
                this.render();
            }
            zoomAt(x, y, factor) {
                const scale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                const worldX = this.centerX + (x - this.canvas.width / 2) * scale;
                const worldY = this.centerY + (y - this.canvas.height / 2) * scale;
                
                this.zoom *= factor;
                
                const newScale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                this.centerX = worldX - (x - this.canvas.width / 2) * newScale;
                this.centerY = worldY - (y - this.canvas.height / 2) * newScale;
                
                this.updateMaxIterations();
                this.updateInfo();
                this.render();
            }
            updateMaxIterations() {
                // Adjust iterations based on zoom and quality level
                const baseIterations = 50 + (this.qualityLevel * 30);
                this.maxIterations = Math.min(1000, Math.max(50, Math.floor(baseIterations + Math.log2(this.zoom) * 50)));
            }
            resetView() {
                this.centerX = 2.5;
                this.centerY = 2.5;
                this.zoom = 1;
                this.updateMaxIterations();
                this.clearCache();
                this.updateInfo();
                this.render();
            }
            navigateToLocation(location) {
                this.centerX = location.x;
                this.centerY = location.y;
                this.zoom = location.zoom;
                this.updateMaxIterations();
                this.clearCache();
                this.updateInfo();
                this.showNotification(`Navigated to ${location.name}`);
                this.render();
            }
            clearCache() {
                this.tileCache.clear();
            }
            scheduleRender() {
                if (this.renderTimeout) {
                    clearTimeout(this.renderTimeout);
                }
                this.renderTimeout = setTimeout(() => this.render(), 100);
            }
            render() {
                // Cancel any ongoing render
                this.cancelRender = true;
                
                // Clear the canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Show loading indicator
                this.loading.classList.add('active');
                
                // Set up new render
                this.cancelRender = false;
                this.visibleTiles.clear();
                
                // Calculate visible tiles
                const tilesX = Math.ceil(this.canvas.width / this.tileSize);
                const tilesY = Math.ceil(this.canvas.height / this.tileSize);
                
                // Create render queue
                this.renderQueue = [];
                for (let y = 0; y < tilesY; y++) {
                    for (let x = 0; x < tilesX; x++) {
                        this.renderQueue.push({ x, y });
                    }
                }
                
                // Start rendering
                this.isRendering = true;
                this.renderNextTile();
            }
            renderNextTile() {
                if (!this.isRendering || this.cancelRender) {
                    this.isRendering = false;
                    this.loading.classList.remove('active');
                    return;
                }
                
                if (this.renderQueue.length === 0) {
                    this.isRendering = false;
                    this.loading.classList.remove('active');
                    return;
                }
                
                // Get next tile
                const tile = this.renderQueue.shift();
                const tileKey = `${tile.x},${tile.y}`;
                
                // Skip if not visible (shouldn't happen with our queue, but just in case)
                if (!this.isTileVisible(tile.x, tile.y)) {
                    this.renderNextTile();
                    return;
                }
                
                // Check if tile is in cache
                if (this.tileCache.has(tileKey)) {
                    const imageData = this.tileCache.get(tileKey);
                    this.ctx.putImageData(imageData, tile.x * this.tileSize, tile.y * this.tileSize);
                    this.renderNextTile();
                    return;
                }
                
                // Render the tile
                this.renderTile(tile.x, tile.y, () => {
                    // Continue rendering next tile
                    requestAnimationFrame(() => this.renderNextTile());
                });
            }
            isTileVisible(tileX, tileY) {
                const x = tileX * this.tileSize;
                const y = tileY * this.tileSize;
                return x < this.canvas.width && y < this.canvas.height;
            }
            renderTile(tileX, tileY, callback) {
                const tileWidth = Math.min(this.tileSize, this.canvas.width - tileX * this.tileSize);
                const tileHeight = Math.min(this.tileSize, this.canvas.height - tileY * this.tileSize);
                
                // Create temporary canvas for this tile
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = tileWidth;
                tileCanvas.height = tileHeight;
                const tileCtx = tileCanvas.getContext('2d');
                
                // Get image data for the tile
                const imageData = tileCtx.createImageData(tileWidth, tileHeight);
                const data = imageData.data;
                
                // Calculate scale and offset for this tile
                const scale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                const offsetX = this.centerX - (this.canvas.width / 2) * scale;
                const offsetY = this.centerY - (this.canvas.height / 2) * scale;
                
                // Render the tile
                for (let y = 0; y < tileHeight; y++) {
                    for (let x = 0; x < tileWidth; x++) {
                        const a = (tileX * this.tileSize + x) * scale + offsetX;
                        const b = (tileY * this.tileSize + y) * scale + offsetY;
                        
                        const lyapunov = this.calculateLyapunov(a, b);
                        const color = this.getColor(lyapunov);
                        
                        const index = (y * tileWidth + x) * 4;
                        data[index] = color.r;
                        data[index + 1] = color.g;
                        data[index + 2] = color.b;
                        data[index + 3] = 255;
                    }
                }
                
                // Put the tile on the main canvas
                this.ctx.putImageData(imageData, tileX * this.tileSize, tileY * this.tileSize);
                
                // Cache the tile
                const tileKey = `${tileX},${tileY}`;
                this.tileCache.set(tileKey, imageData);
                
                // Limit cache size
                if (this.tileCache.size > 100) {
                    // Remove oldest entry (simple approach)
                    const firstKey = this.tileCache.keys().next().value;
                    this.tileCache.delete(firstKey);
                }
                
                // Callback to continue rendering
                callback();
            }
            calculateLyapunov(a, b) {
                let x = 0.5;
                let sum = 0;
                
                // Iterate through the sequence pattern
                for (let i = 0; i < this.maxIterations; i++) {
                    const patternIndex = i % this.sequencePattern.length;
                    const r = this.sequencePattern[patternIndex] === 'a' ? a : b;
                    
                    // Logistic map: x_{n+1} = r * x_n * (1 - x_n)
                    x = r * x * (1 - x);
                    
                    // Calculate derivative for Lyapunov exponent
                    const derivative = Math.abs(r * (1 - 2 * x));
                    
                    // Avoid log(0) which would be -Infinity
                    if (derivative > 0) {
                        sum += Math.log(derivative);
                    }
                }
                
                // Lyapunov exponent is the average of the log of the derivatives
                const lyapunov = sum / this.maxIterations;
                
                return lyapunov;
            }
            getColor(lyapunov) {
                // Lyapunov exponent can be positive (chaos) or negative (stability)
                // We'll map these values to colors
                
                // Normalize the value to a range of 0-1
                let t;
                if (lyapunov < 0) {
                    // Negative values (stability) - map to 0-0.5
                    t = 0.5 + lyapunov / 2;  // lyapunov is negative, so this subtracts
                } else {
                    // Positive values (chaos) - map to 0.5-1
                    t = 0.5 + Math.min(lyapunov / 2, 0.5);
                }
                
                // Ensure t is in the range [0, 1]
                t = Math.max(0, Math.min(1, t));
                
                switch(this.colorScheme) {
                    case 'classic':
                        // Classic Lyapunov coloring: blue for stability, red for chaos
                        if (lyapunov < 0) {
                            // Stable regions - blue gradient
                            const intensity = Math.min(1, Math.abs(lyapunov) * 2);
                            return {
                                r: Math.floor(intensity * 50),
                                g: Math.floor(intensity * 100),
                                b: Math.floor(150 + intensity * 105)
                            };
                        } else {
                            // Chaotic regions - red gradient
                            const intensity = Math.min(1, lyapunov * 2);
                            return {
                                r: Math.floor(150 + intensity * 105),
                                g: Math.floor(intensity * 50),
                                b: Math.floor(intensity * 50)
                            };
                        }
                    
                    case 'fire':
                        return {
                            r: Math.floor(255 * t),
                            g: Math.floor(255 * Math.max(0, t * 2 - 1)),
                            b: Math.floor(255 * Math.max(0, t * 3 - 2))
                        };
                    
                    case 'ocean':
                        return {
                            r: Math.floor(255 * t * 0.3),
                            g: Math.floor(255 * t * 0.7),
                            b: Math.floor(255 * t)
                        };
                    
                    case 'psychedelic':
                        const hue = t * 360;
                        return this.hslToRgb(hue, 100, 50);
                    
                    case 'grayscale':
                        const gray = Math.floor(255 * t);
                        return { r: gray, g: gray, b: gray };
                    
                    default:
                        return { r: 255, g: 255, b: 255 };
                }
            }
            hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
            exportImage() {
                // Disable export button during export
                const exportBtn = document.getElementById('exportBtn');
                exportBtn.disabled = true;
                exportBtn.textContent = 'Exporting...';
                
                // Create a temporary canvas to ensure full quality export
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                
                // Copy the current canvas content
                tempCtx.drawImage(this.canvas, 0, 0);
                
                // Convert to data URL
                const dataURL = tempCanvas.toDataURL('image/png');
                
                // Create download link
                const link = document.createElement('a');
                link.download = `lyapunov_${this.sequencePattern}_${Date.now()}.png`;
                link.href = dataURL;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Re-enable export button
                exportBtn.disabled = false;
                exportBtn.textContent = 'Export as Image';
                
                // Show notification
                this.showNotification('Image exported successfully!');
            }
            showNotification(message) {
                this.notification.textContent = message;
                this.notification.classList.add('show');
                
                setTimeout(() => {
                    this.notification.classList.remove('show');
                }, 3000);
            }
            updateInfo() {
                document.getElementById('zoomLevel').textContent = this.zoom.toFixed(2) + 'x';
                document.getElementById('centerCoords').textContent = 
                    `(${this.centerX.toFixed(6)}, ${this.centerY.toFixed(6)})`;
                document.getElementById('iterations').textContent = this.maxIterations;
            }
        }
        // Initialize the explorer when the page loads
        const explorer = new LyapunovExplorer();
    </script>
</body>
</html>