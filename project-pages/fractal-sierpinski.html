<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sierpiński Triangle Explorer</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
</head>
<body class="fractal-page">
    <nav>
        <div class="nav-container">
            <div class="logo"><a href="/index.html">Mike Wang</a></div>
            <ul class="nav-links external-links">
                <li><a href="/collections.html">Collections</a></li>
            </ul>
        </div>
    </nav>
    <div class="interactive-section interactive-section">
        <canvas id="canvas"></canvas>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span>Rendering...</span>
        </div>

        <div class="controls">
            <h2>Sierpiński Triangle Explorer</h2>
            
            <div class="direction-controls">
                <div></div>
                <button class="direction-btn" data-direction="up">↑</button>
                <div></div>
                <button class="direction-btn" data-direction="left">←</button>
                <button class="direction-btn center" data-direction="reset">⌂</button>
                <button class="direction-btn" data-direction="right">→</button>
                <div></div>
                <button class="direction-btn" data-direction="down">↓</button>
                <div></div>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn">Zoom In</button>
                <button class="zoom-btn" id="zoomOut">Zoom Out</button>
            </div>

            <button class="reset-btn" id="resetView">Reset View</button>

            <div class="sierpinski-controls">
                <label for="sierpinskiPreset">Fractal Type</label>
                <select id="sierpinskiPreset">
                    <option value="triangle">Sierpiński Triangle</option>
                    <option value="carpet">Sierpiński Carpet</option>
                    <option value="hexagon">Sierpiński Hexagon</option>
                    <option value="pentagon">Sierpiński Pentagon</option>
                    <option value="custom">Custom Fractal</option>
                </select>
                
                <div class="depth-control">
                    <label for="depth">Recursion Depth: <span id="depthValue">6</span></label>
                    <input type="range" id="depth" class="depth-input" min="0" max="10" value="6" step="1">
                    <div class="quality-labels">
                        <span>Low</span>
                        <span>Medium</span>
                        <span>High</span>
                    </div>
                    <div class="help-text">Maximum depth: 10 (higher values create exponentially more detail)</div>
                </div>

                <div class="custom-params" id="customParams">
                    <div class="param-row">
                        <div style="flex: 1;">
                            <div class="param-label">Vertices</div>
                            <input type="number" id="customVertices" class="param-input" min="3" max="12" value="3" step="1">
                        </div>
                        <div style="flex: 1;">
                            <div class="param-label">Ratio</div>
                            <input type="number" id="customRatio" class="param-input" min="0.1" max="0.9" value="0.5" step="0.05">
                        </div>
                    </div>
                    <div class="param-row">
                        <div style="flex: 1;">
                            <div class="param-label">Iterations</div>
                            <input type="number" id="customIterations" class="param-input" min="1000" max="1000000" value="50000" step="1000">
                        </div>
                    </div>
                    <button class="apply-custom-btn" id="applyCustom">Apply Custom Parameters</button>
                </div>
            </div>

            <div class="locations">
                <label for="locationSelect">Interesting Locations</label>
                <select id="locationSelect">
                    <option value="">Select a location...</option>
                    <option value="center">Center View</option>
                    <option value="corner">Corner Detail</option>
                    <option value="edge">Edge Detail</option>
                    <option value="pattern">Pattern Center</option>
                </select>
            </div>

            <div class="color-scheme">
                <label for="colorScheme">Color Scheme</label>
                <select id="colorScheme">
                    <option value="classic">Classic</option>
                    <option value="fire">Fire</option>
                    <option value="ocean">Ocean</option>
                    <option value="psychedelic">Psychedelic</option>
                    <option value="grayscale">Grayscale</option>
                </select>
            </div>

            <div class="export-section">
                <button class="export-btn" id="exportBtn">Export as Image</button>
            </div>

            <div class="info">
                <div class="info-item">
                    <span class="info-label">Zoom:</span> <span id="zoomLevel">1.0x</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Center:</span> <span id="centerCoords">(0, 0)</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Type:</span> <span id="fractalType">Triangle</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Depth:</span> <span id="depthLevel">6</span>
                </div>
            </div>
        </div>
    </div>

    <div class="introduction-section">
        <h1>Sierpiński Fractals</h1>
        <p>
            Sierpiński fractals are a family of self-similar geometric patterns that demonstrate the beauty of mathematical recursion and infinite complexity. Named after Polish mathematician Wacław Sierpiński, these fractals are created through simple recursive rules that produce stunningly intricate patterns.
        </p>

        <h2>Interactive Explorer</h2>
        <p>
            The interactive explorer above allows you to explore various Sierpiński fractals in real-time. You can:
        </p>
        <ul>
            <li>Navigate through different fractal types including triangles, carpets, hexagons, and pentagons</li>
            <li>Adjust the recursion depth to see how complexity emerges from simple rules</li>
            <li>Pan and zoom to explore the infinite detail of these mathematical structures</li>
            <li>Customize your own fractals with unique parameters</li>
            <li>Export your favorite views as high-quality images</li>
        </ul>

        <h2>Types of Sierpiński Fractals</h2>
        <div class="fractal-grid">
            <div class="fractal-card">
                <h3>Sierpiński Triangle</h3>
                <p>The most famous Sierpiński fractal, created by recursively subdividing a triangle into four smaller triangles and removing the center one.</p>
            </div>
            <div class="fractal-card">
                <h3>Sierpiński Carpet</h3>
                <p>A two-dimensional fractal formed by subdividing a square into nine smaller squares and removing the center one.</p>
            </div>
            <div class="fractal-card">
                <h3>Sierpiński Hexagon</h3>
                <p>A six-sided variant where each hexagon is surrounded by six smaller hexagons in a recursive pattern.</p>
            </div>
            <div class="fractal-card">
                <h3>Sierpiński Pentagon</h3>
                <p>A five-sided fractal that demonstrates how recursive subdivision can be applied to any regular polygon.</p>
            </div>
        </div>

        <h2>Mathematical Properties</h2>
        <p>
            Sierpiński fractals exhibit fascinating mathematical properties that make them subjects of ongoing research:
        </p>
        <ul>
            <li><strong>Self-Similarity:</strong> Each part of the fractal contains a smaller copy of the entire structure</li>
            <li><strong>Infinite Perimeter:</strong> The boundary length approaches infinity as recursion depth increases</li>
            <li><strong>Zero Area:</strong> Despite their visual presence, these fractals have zero mathematical area</li>
            <li><strong>Fractal Dimension:</strong> They have non-integer dimensions between 1 and 2</li>
        </ul>

        <h3>Fractal Dimension</h3>
        <p>
            Unlike traditional geometric shapes, fractals have fractional dimensions. The Sierpiński Triangle, for example, has a dimension of approximately 1.585, indicating it's more complex than a line (dimension 1) but less complex than a solid plane (dimension 2).
        </p>

        <h2>Applications in Science and Nature</h2>
        <p>
            While Sierpiński fractals began as mathematical curiosities, they have found applications in various fields:
        </p>
        <ul>
            <li><strong>Antenna Design:</strong> Fractal antennas can operate at multiple frequencies</li>
            <li><strong>Computer Graphics:</strong> Used for generating natural-looking textures and landscapes</li>
            <li><strong>Network Design:</strong> Fractal patterns optimize network topologies</li>
            <li><strong>Material Science:</strong> Fractal structures create materials with unique properties</li>
        </ul>

        <h2>Creating Your Own Fractals</h2>
        <p>
            The "Custom Fractal" option in the explorer lets you experiment with your own parameters. By adjusting the number of vertices and the ratio between iterations, you can discover entirely new fractal patterns. Each combination produces unique structures that may have never been seen before!
        </p>
        <p>
            This exploration demonstrates how simple rules can generate infinite complexity—a fundamental principle in chaos theory and complex systems. As you zoom into these fractals, you'll discover that the pattern repeats forever, revealing the infinite nature of mathematical beauty.
        </p>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        class SierpinskiExplorer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.notification = document.getElementById('notification');
                
                // View parameters
                this.centerX = 0;
                this.centerY = 0;
                this.zoom = 1;
                this.colorScheme = 'classic';
                
                // Sierpiński parameters
                this.fractalType = 'triangle';
                this.recursionDepth = 6;
                
                // Custom parameters
                this.customParams = {
                    vertices: 3,
                    ratio: 0.5,
                    iterations: 50000
                };
                
                // Performance settings
                this.isRendering = false;
                this.cancelRender = false;
                this.isDragging = false;
                this.dragVelocity = { x: 0, y: 0 };
                this.lastDragTime = 0;
                this.renderTimeout = null;
                
                // Interesting locations
                this.interestingLocations = {
                    center: { name: "Center View", x: 0, y: 0, zoom: 1 },
                    corner: { name: "Corner Detail", x: 0.3, y: 0.3, zoom: 3 },
                    edge: { name: "Edge Detail", x: 0.2, y: -0.1, zoom: 4 },
                    pattern: { name: "Pattern Center", x: 0.1, y: 0.1, zoom: 8 }
                };
                
                this.init();
            }

            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.render();
                
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.render();
                });
            }

            resizeCanvas() {
                // Set canvas size to match viewport
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                // Mouse events with improved drag handling
                this.canvas.addEventListener('mousedown', (e) => this.startDrag(e));
                this.canvas.addEventListener('mousemove', (e) => this.drag(e));
                this.canvas.addEventListener('mouseup', () => this.endDrag());
                this.canvas.addEventListener('mouseleave', () => this.endDrag());
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.startDrag(e.touches[0]));
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.drag(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', () => this.endDrag());
                
                // Wheel zoom
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoomAt(e.clientX, e.clientY, delta);
                });
                
                // Direction controls
                document.querySelectorAll('.direction-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const direction = btn.dataset.direction;
                        if (direction === 'reset') {
                            this.resetView();
                        } else {
                            this.pan(direction);
                        }
                    });
                });
                
                // Zoom buttons
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 1.5);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 0.67);
                });
                
                // Reset view
                document.getElementById('resetView').addEventListener('click', () => {
                    this.resetView();
                });
                
                // Fractal preset selector
                document.getElementById('sierpinskiPreset').addEventListener('change', (e) => {
                    this.fractalType = e.target.value;
                    
                    // Show/hide custom parameters
                    const customParams = document.getElementById('customParams');
                    if (this.fractalType === 'custom') {
                        customParams.classList.add('active');
                    } else {
                        customParams.classList.remove('active');
                    }
                    
                    this.updateInfo();
                    this.render();
                });
                
                // Depth control
                const depthSlider = document.getElementById('depth');
                depthSlider.addEventListener('input', (e) => {
                    this.recursionDepth = parseInt(e.target.value);
                    document.getElementById('depthValue').textContent = this.recursionDepth;
                    document.getElementById('depthLevel').textContent = this.recursionDepth;
                    
                    // Show warning for high depths
                    if (this.recursionDepth > 7) {
                        this.showNotification('Warning: High recursion depth may cause performance issues', 'warning');
                    }
                    
                    this.render();
                });
                
                // Apply custom parameters
                document.getElementById('applyCustom').addEventListener('click', () => {
                    this.customParams.vertices = parseInt(document.getElementById('customVertices').value);
                    this.customParams.ratio = parseFloat(document.getElementById('customRatio').value);
                    this.customParams.iterations = parseInt(document.getElementById('customIterations').value);
                    
                    this.showNotification('Custom parameters applied');
                    this.render();
                });
                
                // Location selector
                document.getElementById('locationSelect').addEventListener('change', (e) => {
                    const locationKey = e.target.value;
                    if (locationKey && this.interestingLocations[locationKey]) {
                        this.navigateToLocation(this.interestingLocations[locationKey]);
                        e.target.value = ''; // Reset selector
                    }
                });
                
                // Color scheme
                document.getElementById('colorScheme').addEventListener('change', (e) => {
                    this.colorScheme = e.target.value;
                    this.render();
                });
                
                // Export button
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportImage();
                });
            }

            startDrag(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.lastDragTime = Date.now();
                this.dragVelocity = { x: 0, y: 0 };
                
                // Reduce quality during drag for better performance
                this.canvas.style.cursor = 'grabbing';
            }

            drag(e) {
                if (!this.isDragging) return;
                
                const currentTime = Date.now();
                const deltaTime = currentTime - this.lastDragTime;
                
                const dx = e.clientX - this.lastX;
                const dy = e.clientY - this.lastY;
                
                // Calculate velocity for smooth momentum
                if (deltaTime > 0) {
                    this.dragVelocity.x = dx / deltaTime;
                    this.dragVelocity.y = dy / deltaTime;
                }
                
                const scale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                this.centerX += dx * scale;
                this.centerY += dy * scale;
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.lastDragTime = currentTime;
                
                this.updateInfo();
                
                // Debounced render during drag
                if (!this.renderTimeout) {
                    this.renderTimeout = setTimeout(() => {
                        this.render(true); // Render with reduced quality during drag
                        this.renderTimeout = null;
                    }, 16); // ~60fps
                }
            }

            endDrag() {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                this.canvas.style.cursor = 'grab';
                
                // Apply momentum for smooth stop
                this.applyMomentum();
                
                // Clear timeout and render full quality
                if (this.renderTimeout) {
                    clearTimeout(this.renderTimeout);
                    this.renderTimeout = null;
                }
                
                // Render full quality after drag
                setTimeout(() => this.render(false), 100);
            }

            applyMomentum() {
                const friction = 0.95;
                const minVelocity = 0.01;
                
                const animate = () => {
                    if (Math.abs(this.dragVelocity.x) < minVelocity && 
                        Math.abs(this.dragVelocity.y) < minVelocity) {
                        return;
                    }
                    
                    const scale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                    this.centerX -= this.dragVelocity.x * scale * 16;
                    this.centerY -= this.dragVelocity.y * scale * 16;
                    
                    this.dragVelocity.x *= friction;
                    this.dragVelocity.y *= friction;
                    
                    this.updateInfo();
                    this.render(true); // Reduced quality during momentum
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            }

            pan(direction) {
                const moveAmount = 0.5 / this.zoom;
                
                switch(direction) {
                    case 'up':
                        this.centerY -= moveAmount;
                        break;
                    case 'down':
                        this.centerY += moveAmount;
                        break;
                    case 'left':
                        this.centerX -= moveAmount;
                        break;
                    case 'right':
                        this.centerX += moveAmount;
                        break;
                }
                
                this.updateInfo();
                this.render();
            }

            zoomAt(x, y, factor) {
                const scale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                const worldX = this.centerX + (x - this.canvas.width / 2) * scale;
                const worldY = this.centerY + (y - this.canvas.height / 2) * scale;
                
                this.zoom *= factor;
                
                const newScale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                this.centerX = worldX - (x - this.canvas.width / 2) * newScale;
                this.centerY = worldY - (y - this.canvas.height / 2) * newScale;
                
                this.updateInfo();
                this.render();
            }

            resetView() {
                this.centerX = 0;
                this.centerY = 0;
                this.zoom = 1;
                this.updateInfo();
                this.render();
            }

            navigateToLocation(location) {
                this.centerX = location.x;
                this.centerY = location.y;
                this.zoom = location.zoom;
                this.updateInfo();
                this.showNotification(`Navigated to ${location.name}`);
                this.render();
            }

            render(isLowQuality = false) {
                // Cancel any ongoing render
                this.cancelRender = true;
                
                // Clear the canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Show loading indicator for high quality renders
                if (!isLowQuality) {
                    this.loading.classList.add('active');
                }
                
                // Set up new render
                this.cancelRender = false;
                
                // Cap recursion depth for performance
                const actualDepth = Math.min(this.recursionDepth, isLowQuality ? 3 : 10);
                
                // Start rendering
                this.renderRecursive(actualDepth);
                
                if (!isLowQuality) {
                    this.loading.classList.remove('active');
                }
            }

            renderRecursive(depth) {
                // Calculate scale and offset for the canvas
                const scale = Math.min(this.canvas.width, this.canvas.height) / 2.5 * this.zoom;
                const offsetX = this.canvas.width / 2 + this.centerX * scale;
                const offsetY = this.canvas.height / 2 + this.centerY * scale;
                
                // Set up transformation
                this.ctx.save();
                
                if (this.fractalType === 'triangle') {
                    this.renderSierpinskiTriangle(offsetX, offsetY, scale, 0, depth);
                } else if (this.fractalType === 'carpet') {
                    this.renderSierpinskiCarpet(offsetX, offsetY, scale, 0, depth);
                } else if (this.fractalType === 'hexagon') {
                    this.renderSierpinskiHexagon(offsetX, offsetY, scale, 0, depth);
                } else if (this.fractalType === 'pentagon') {
                    this.renderSierpinskiPentagon(offsetX, offsetY, scale, 0, depth);
                } else if (this.fractalType === 'custom') {
                    this.renderCustomFractal(offsetX, offsetY, scale, 0, depth);
                }
                
                this.ctx.restore();
                this.updateInfo();
            }

            renderSierpinskiTriangle(centerX, centerY, size, currentDepth, maxDepth) {
                if (currentDepth >= maxDepth) {
                    // Draw the triangle
                    const height = size * Math.sqrt(3) / 2;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY - height * 2/3);
                    this.ctx.lineTo(centerX - size/2, centerY + height/3);
                    this.ctx.lineTo(centerX + size/2, centerY + height/3);
                    this.ctx.closePath();
                    
                    const color = this.getColor(currentDepth / maxDepth, 0, 0);
                    this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    this.ctx.fill();
                    return;
                }
                
                // Calculate the three vertices of the main triangle
                const height = size * Math.sqrt(3) / 2;
                const top = { x: centerX, y: centerY - height * 2/3 };
                const left = { x: centerX - size/2, y: centerY + height/3 };
                const right = { x: centerX + size/2, y: centerY + height/3 };
                
                // Calculate midpoints
                const midTopLeft = {
                    x: (top.x + left.x) / 2,
                    y: (top.y + left.y) / 2
                };
                const midTopRight = {
                    x: (top.x + right.x) / 2,
                    y: (top.y + right.y) / 2
                };
                const midLeftRight = {
                    x: (left.x + right.x) / 2,
                    y: (left.y + right.y) / 2
                };
                
                // Recursively draw the three smaller triangles
                this.renderSierpinskiTriangle(
                    (top.x + midTopLeft.x + midTopRight.x) / 3,
                    (top.y + midTopLeft.y + midTopRight.y) / 3,
                    size / 2,
                    currentDepth + 1,
                    maxDepth
                );
                
                this.renderSierpinskiTriangle(
                    (left.x + midTopLeft.x + midLeftRight.x) / 3,
                    (left.y + midTopLeft.y + midLeftRight.y) / 3,
                    size / 2,
                    currentDepth + 1,
                    maxDepth
                );
                
                this.renderSierpinskiTriangle(
                    (right.x + midTopRight.x + midLeftRight.x) / 3,
                    (right.y + midTopRight.y + midLeftRight.y) / 3,
                    size / 2,
                    currentDepth + 1,
                    maxDepth
                );
            }

            renderSierpinskiCarpet(centerX, centerY, size, currentDepth, maxDepth) {
                if (currentDepth >= maxDepth) {
                    // Draw the square
                    const color = this.getColor(currentDepth / maxDepth, 0, 0);
                    this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    this.ctx.fillRect(centerX - size/2, centerY - size/2, size, size);
                    return;
                }
                
                const third = size / 3;
                
                // Draw the 8 smaller squares (skip the center)
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue; // Skip center
                        
                        this.renderSierpinskiCarpet(
                            centerX + i * third,
                            centerY + j * third,
                            third,
                            currentDepth + 1,
                            maxDepth
                        );
                    }
                }
            }

            renderSierpinskiHexagon(centerX, centerY, size, currentDepth, maxDepth) {
                if (currentDepth >= maxDepth) {
                    // Draw the hexagon
                    this.ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI) / 3;
                        const x = centerX + size * Math.cos(angle);
                        const y = centerY + size * Math.sin(angle);
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.closePath();
                    
                    const color = this.getColor(currentDepth / maxDepth, 0, 0);
                    this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    this.ctx.fill();
                    return;
                }
                
                // Draw 6 smaller hexagons around the center
                const newSize = size / 3;
                const distance = size * 2/3;
                
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const x = centerX + distance * Math.cos(angle);
                    const y = centerY + distance * Math.sin(angle);
                    
                    this.renderSierpinskiHexagon(x, y, newSize, currentDepth + 1, maxDepth);
                }
            }

            renderSierpinskiPentagon(centerX, centerY, size, currentDepth, maxDepth) {
                if (currentDepth >= maxDepth) {
                    // Draw the pentagon
                    this.ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                        const x = centerX + size * Math.cos(angle);
                        const y = centerY + size * Math.sin(angle);
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.closePath();
                    
                    const color = this.getColor(currentDepth / maxDepth, 0, 0);
                    this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    this.ctx.fill();
                    return;
                }
                
                // Draw 5 smaller pentagons
                const newSize = size / 2.5;
                const distance = size * 0.7;
                
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                    const x = centerX + distance * Math.cos(angle);
                    const y = centerY + distance * Math.sin(angle);
                    
                    this.renderSierpinskiPentagon(x, y, newSize, currentDepth + 1, maxDepth);
                }
            }

            renderCustomFractal(centerX, centerY, size, currentDepth, maxDepth) {
                if (currentDepth >= maxDepth) {
                    // Draw the polygon based on custom vertices
                    const vertices = this.customParams.vertices;
                    this.ctx.beginPath();
                    for (let i = 0; i < vertices; i++) {
                        const angle = (i * 2 * Math.PI) / vertices - Math.PI / 2;
                        const x = centerX + size * Math.cos(angle);
                        const y = centerY + size * Math.sin(angle);
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.closePath();
                    
                    const color = this.getColor(currentDepth / maxDepth, 0, 0);
                    this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    this.ctx.fill();
                    return;
                }
                
                // Draw smaller polygons around the perimeter
                const vertices = this.customParams.vertices;
                const newSize = size * this.customParams.ratio;
                const distance = size * (1 - this.customParams.ratio);
                
                for (let i = 0; i < vertices; i++) {
                    const angle = (i * 2 * Math.PI) / vertices - Math.PI / 2;
                    const x = centerX + distance * Math.cos(angle);
                    const y = centerY + distance * Math.sin(angle);
                    
                    this.renderCustomFractal(x, y, newSize, currentDepth + 1, maxDepth);
                }
            }

            getColor(progress, x, y) {
                switch(this.colorScheme) {
                    case 'classic':
                        const t = progress;
                        return {
                            r: Math.floor(255 * t),
                            g: Math.floor(255 * (1 - t)),
                            b: Math.floor(128 + 127 * Math.sin(progress * Math.PI * 2))
                        };
                    
                    case 'fire':
                        return {
                            r: Math.floor(255 * Math.min(1, progress * 2)),
                            g: Math.floor(255 * Math.max(0, progress * 2 - 0.5)),
                            b: Math.floor(255 * Math.max(0, progress * 3 - 2))
                        };
                    
                    case 'ocean':
                        return {
                            r: Math.floor(255 * progress * 0.3),
                            g: Math.floor(255 * progress * 0.7),
                            b: Math.floor(255 * progress)
                        };
                    
                    case 'psychedelic':
                        const hue = (progress * 360 + Math.atan2(y, x) * 180 / Math.PI) % 360;
                        return this.hslToRgb(hue, 100, 50);
                    
                    case 'grayscale':
                        const gray = Math.floor(255 * progress);
                        return { r: gray, g: gray, b: gray };
                    
                    default:
                        return { r: 255, g: 255, b: 255 };
                }
            }

            hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }

            exportImage() {
                // Disable export button during export
                const exportBtn = document.getElementById('exportBtn');
                exportBtn.disabled = true;
                exportBtn.textContent = 'Exporting...';
                
                // Create a temporary canvas to ensure full quality export
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                
                // Copy the current canvas content
                tempCtx.drawImage(this.canvas, 0, 0);
                
                // Convert to data URL
                const dataURL = tempCanvas.toDataURL('image/png');
                
                // Create download link
                const link = document.createElement('a');
                link.download = `sierpinski_${this.fractalType}_${Date.now()}.png`;
                link.href = dataURL;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Re-enable export button
                exportBtn.disabled = false;
                exportBtn.textContent = 'Export as Image';
                
                // Show notification
                this.showNotification('Image exported successfully!');
            }

            showNotification(message, type = 'success') {
                this.notification.textContent = message;
                this.notification.className = `notification ${type}`;
                this.notification.classList.add('show');
                
                setTimeout(() => {
                    this.notification.classList.remove('show');
                }, 3000);
            }

            updateInfo() {
                document.getElementById('zoomLevel').textContent = this.zoom.toFixed(2) + 'x';
                document.getElementById('centerCoords').textContent = 
                    `(${this.centerX.toFixed(6)}, ${this.centerY.toFixed(6)})`;
                document.getElementById('fractalType').textContent = 
                    this.fractalType.charAt(0).toUpperCase() + this.fractalType.slice(1);
                document.getElementById('depthLevel').textContent = this.recursionDepth;
            }
        }

        // Initialize the explorer when the page loads
        const explorer = new SierpinskiExplorer();
    </script>
</body>
</html>