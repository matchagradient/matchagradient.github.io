<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot Set Explorer</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
</head>
<body class="fractal-page">
    <nav>
        <div class="nav-container">
            <div class="logo"><a href="/index.html">Mike Wang</a></div>
            <ul class="nav-links external-links">
                <li><a href="/collections.html">Collections</a></li>
            </ul>
        </div>
    </nav>
    
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span>Rendering...</span>
        </div>
        <div class="controls">
            <h2>Mandelbrot Explorer</h2>
            
            <div class="direction-controls">
                <div></div>
                <button class="direction-btn" data-direction="up">↑</button>
                <div></div>
                <button class="direction-btn" data-direction="left">←</button>
                <button class="direction-btn center" data-direction="reset">⌂</button>
                <button class="direction-btn" data-direction="right">→</button>
                <div></div>
                <button class="direction-btn" data-direction="down">↓</button>
                <div></div>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn">Zoom In</button>
                <button class="zoom-btn" id="zoomOut">Zoom Out</button>
            </div>
            <button class="reset-btn" id="resetView">Reset View</button>
            <div class="locations">
                <label for="locationSelect">Interesting Locations</label>
                <select id="locationSelect">
                    <option value="">Select a location...</option>
                    <option value="main">Main Cardioid</option>
                    <option value="seahorse">Seahorse Valley</option>
                    <option value="spiral">Spiral</option>
                    <option value="mini">Mini Mandelbrot</option>
                    <option value="lightning">Lightning</option>
                    <option value="elephant">Elephant Valley</option>
                    <option value="dragon">Dragon Valley</option>
                    <option value="julia">Julia Set Connection</option>
                </select>
            </div>
            <div class="color-scheme">
                <label for="colorScheme">Color Scheme</label>
                <select id="colorScheme">
                    <option value="classic">Classic</option>
                    <option value="fire">Fire</option>
                    <option value="ocean">Ocean</option>
                    <option value="psychedelic">Psychedelic</option>
                    <option value="grayscale">Grayscale</option>
                </select>
            </div>
            <div class="performance-controls">
                <label for="quality">Quality vs Performance</label>
                <input type="range" id="quality" class="quality-slider" min="1" max="5" value="3">
                <div class="quality-labels">
                    <span>Fast</span>
                    <span>Balanced</span>
                    <span>High Quality</span>
                </div>
            </div>
            <div class="export-section">
                <button class="export-btn" id="exportBtn">Export as Image</button>
            </div>
            <div class="info">
                <div class="info-item">
                    <span class="info-label">Zoom:</span> <span id="zoomLevel">1.0x</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Center:</span> <span id="centerCoords">(-0.5, 0)</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Iterations:</span> <span id="iterations">100</span>
                </div>
            </div>
        </div>
        <div class="notification" id="notification"></div>
    </div>
    
    <section class="introduction">
        <h1>The Mandelbrot Set</h1>
        <p>
            The <a href="https://en.wikipedia.org/wiki/Mandelbrot_set" class="highlight" target="_blank" rel="noopener noreferrer">Mandelbrot Set</a>
            is one of the most famous and beautiful examples of a fractal in mathematics. 
            Named after mathematician Benoit Mandelbrot, who studied and popularized it, this set has captivated mathematicians, 
            artists, and enthusiasts alike with its infinite complexity and self-similar patterns.
        </p>
        <p>
            At its core, the Mandelbrot Set is defined by a simple equation: z<sub>n+1</sub> = z<sub>n</sub>² + c, where z and c are 
            complex numbers. Starting with z₀ = 0, we iterate this equation. If the sequence remains bounded (doesn't escape to infinity), 
            then the complex number c is part of the Mandelbrot Set.
        </p>
        
        <h2>Exploring the Infinite</h2>
        <p>
            What makes the Mandelbrot Set fascinating is its <span class="highlight">infinite complexity</span>. As you zoom into the 
            boundary of the set, you discover an endless world of intricate patterns, spirals, and miniature copies of the entire set. 
            This property of self-similarity at different scales is a hallmark of fractals.
        </p>
        <p>
            The interactive explorer above allows you to navigate this mathematical landscape. You can zoom in to reveal finer details, 
            pan around to explore different regions, and even jump to interesting locations that showcase particularly beautiful or 
            mathematically significant features of the set.
        </p>
        
        <h2>Mathematical Significance</h2>
        <p>
            Beyond its aesthetic appeal, the Mandelbrot Set has profound mathematical implications. It serves as a bridge between 
            complex dynamics, geometry, and topology. The boundary of the set is a fractal with a dimension of 2, making it one of 
            the most complex objects in mathematics.
        </p>
        <p>
            The study of the Mandelbrot Set and related fractals has applications in various fields, including computer graphics, 
            antenna design, data compression, and even in modeling natural phenomena like coastlines, clouds, and mountain ranges.
        </p>
    </section>
    
    <script>
        class MandelbrotExplorer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.notification = document.getElementById('notification');
                
                // View parameters
                this.centerX = -0.5;
                this.centerY = 0;
                this.zoom = 1;
                this.baseMaxIterations = 100;
                this.maxIterations = this.baseMaxIterations;
                this.colorScheme = 'classic';
                
                // Performance settings
                this.qualityLevel = 3; // 1-5 (fast to high quality)
                this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
                this.tileSize = 64; // Size of tiles for progressive rendering
                
                // Interaction state
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                // Rendering state
                this.renderQueue = [];
                this.isRendering = false;
                this.cancelRender = false;
                this.visibleTiles = new Set();
                
                // Cache for previously computed tiles
                this.tileCache = new Map();
                
                // Interesting locations
                this.interestingLocations = {
                    main: { name: "Main Cardioid", x: -0.5, y: 0, zoom: 1 },
                    seahorse: { name: "Seahorse Valley", x: -0.75, y: 0.1, zoom: 50 },
                    spiral: { name: "Spiral", x: -0.1592, y: -1.0317, zoom: 100 },
                    mini: { name: "Mini Mandelbrot", x: -1.25, y: 0, zoom: 10 },
                    lightning: { name: "Lightning", x: -0.7269, y: 0.1889, zoom: 1000 },
                    elephant: { name: "Elephant Valley", x: 0.25, y: 0, zoom: 5 },
                    dragon: { name: "Dragon Valley", x: -0.8, y: 0.156, zoom: 200 },
                    julia: { name: "Julia Set Connection", x: -0.4, y: 0.6, zoom: 300 }
                };
                
                this.init();
            }
            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.render();
                
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.render();
                });
            }
            resizeCanvas() {
                // Set canvas size to match container
                const container = document.getElementById('canvas-container');
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                // Clear cache when resizing
                this.tileCache.clear();
            }
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.startDrag(e));
                this.canvas.addEventListener('mousemove', (e) => this.drag(e));
                this.canvas.addEventListener('mouseup', () => this.endDrag());
                this.canvas.addEventListener('mouseleave', () => this.endDrag());
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.startDrag(e.touches[0]));
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.drag(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', () => this.endDrag());
                
                // Wheel zoom
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoomAt(e.clientX, e.clientY, delta);
                });
                
                // Direction controls
                document.querySelectorAll('.direction-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const direction = btn.dataset.direction;
                        if (direction === 'reset') {
                            this.resetView();
                        } else {
                            this.pan(direction);
                        }
                    });
                });
                
                // Zoom buttons
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 1.5);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 0.67);
                });
                
                // Reset view
                document.getElementById('resetView').addEventListener('click', () => {
                    this.resetView();
                });
                
                // Location selector
                document.getElementById('locationSelect').addEventListener('change', (e) => {
                    const locationKey = e.target.value;
                    if (locationKey && this.interestingLocations[locationKey]) {
                        this.navigateToLocation(this.interestingLocations[locationKey]);
                        e.target.value = ''; // Reset selector
                    }
                });
                
                // Color scheme
                document.getElementById('colorScheme').addEventListener('change', (e) => {
                    this.colorScheme = e.target.value;
                    this.clearCache();
                    this.render();
                });
                
                // Quality slider
                document.getElementById('quality').addEventListener('input', (e) => {
                    this.qualityLevel = parseInt(e.target.value);
                    this.updateMaxIterations();
                    this.clearCache();
                    this.render();
                });
                
                // Export button
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportImage();
                });
            }
            startDrag(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
            }
            drag(e) {
                if (!this.isDragging) return;
                
                const dx = e.clientX - this.lastX;
                const dy = e.clientY - this.lastY;
                
                const scale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                this.centerX -= dx * scale;
                this.centerY -= dy * scale;
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                this.updateInfo();
                this.scheduleRender();
            }
            endDrag() {
                this.isDragging = false;
            }
            pan(direction) {
                const moveAmount = 0.5 / this.zoom;
                
                switch(direction) {
                    case 'up':
                        this.centerY -= moveAmount;
                        break;
                    case 'down':
                        this.centerY += moveAmount;
                        break;
                    case 'left':
                        this.centerX -= moveAmount;
                        break;
                    case 'right':
                        this.centerX += moveAmount;
                        break;
                }
                
                this.updateInfo();
                this.render();
            }
            zoomAt(x, y, factor) {
                const scale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                const worldX = this.centerX + (x - this.canvas.width / 2) * scale;
                const worldY = this.centerY + (y - this.canvas.height / 2) * scale;
                
                this.zoom *= factor;
                
                const newScale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                this.centerX = worldX - (x - this.canvas.width / 2) * newScale;
                this.centerY = worldY - (y - this.canvas.height / 2) * newScale;
                
                this.updateMaxIterations();
                this.updateInfo();
                this.render();
            }
            updateMaxIterations() {
                // Adjust iterations based on zoom and quality level
                const baseIterations = 50 + (this.qualityLevel * 30);
                this.maxIterations = Math.min(1000, Math.max(50, Math.floor(baseIterations + Math.log2(this.zoom) * 50)));
            }
            resetView() {
                this.centerX = -0.5;
                this.centerY = 0;
                this.zoom = 1;
                this.updateMaxIterations();
                this.clearCache();
                this.updateInfo();
                this.render();
            }
            navigateToLocation(location) {
                this.centerX = location.x;
                this.centerY = location.y;
                this.zoom = location.zoom;
                this.updateMaxIterations();
                this.clearCache();
                this.updateInfo();
                this.showNotification(`Navigated to ${location.name}`);
                this.render();
            }
            clearCache() {
                this.tileCache.clear();
            }
            scheduleRender() {
                if (this.renderTimeout) {
                    clearTimeout(this.renderTimeout);
                }
                this.renderTimeout = setTimeout(() => this.render(), 100);
            }
            render() {
                // Cancel any ongoing render
                this.cancelRender = true;
                
                // Clear the canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Show loading indicator
                this.loading.classList.add('active');
                
                // Set up new render
                this.cancelRender = false;
                this.visibleTiles.clear();
                
                // Calculate visible tiles
                const tilesX = Math.ceil(this.canvas.width / this.tileSize);
                const tilesY = Math.ceil(this.canvas.height / this.tileSize);
                
                // Create render queue
                this.renderQueue = [];
                for (let y = 0; y < tilesY; y++) {
                    for (let x = 0; x < tilesX; x++) {
                        this.renderQueue.push({ x, y });
                    }
                }
                
                // Start rendering
                this.isRendering = true;
                this.renderNextTile();
            }
            renderNextTile() {
                if (!this.isRendering || this.cancelRender) {
                    this.isRendering = false;
                    this.loading.classList.remove('active');
                    return;
                }
                
                if (this.renderQueue.length === 0) {
                    this.isRendering = false;
                    this.loading.classList.remove('active');
                    return;
                }
                
                // Get next tile
                const tile = this.renderQueue.shift();
                const tileKey = `${tile.x},${tile.y}`;
                
                // Skip if not visible (shouldn't happen with our queue, but just in case)
                if (!this.isTileVisible(tile.x, tile.y)) {
                    this.renderNextTile();
                    return;
                }
                
                // Check if tile is in cache
                if (this.tileCache.has(tileKey)) {
                    const imageData = this.tileCache.get(tileKey);
                    this.ctx.putImageData(imageData, tile.x * this.tileSize, tile.y * this.tileSize);
                    this.renderNextTile();
                    return;
                }
                
                // Render the tile
                this.renderTile(tile.x, tile.y, () => {
                    // Continue rendering next tile
                    requestAnimationFrame(() => this.renderNextTile());
                });
            }
            isTileVisible(tileX, tileY) {
                const x = tileX * this.tileSize;
                const y = tileY * this.tileSize;
                return x < this.canvas.width && y < this.canvas.height;
            }
            renderTile(tileX, tileY, callback) {
                const tileWidth = Math.min(this.tileSize, this.canvas.width - tileX * this.tileSize);
                const tileHeight = Math.min(this.tileSize, this.canvas.height - tileY * this.tileSize);
                
                // Create temporary canvas for this tile
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = tileWidth;
                tileCanvas.height = tileHeight;
                const tileCtx = tileCanvas.getContext('2d');
                
                // Get image data for the tile
                const imageData = tileCtx.createImageData(tileWidth, tileHeight);
                const data = imageData.data;
                
                // Calculate scale and offset for this tile
                const scale = 4 / (this.zoom * Math.min(this.canvas.width, this.canvas.height));
                const offsetX = this.centerX - (this.canvas.width / 2) * scale;
                const offsetY = this.centerY - (this.canvas.height / 2) * scale;
                
                // Render the tile
                for (let y = 0; y < tileHeight; y++) {
                    for (let x = 0; x < tileWidth; x++) {
                        const cx = (tileX * this.tileSize + x) * scale + offsetX;
                        const cy = (tileY * this.tileSize + y) * scale + offsetY;
                        
                        const iterations = this.mandelbrot(cx, cy);
                        const color = this.getColor(iterations);
                        
                        const index = (y * tileWidth + x) * 4;
                        data[index] = color.r;
                        data[index + 1] = color.g;
                        data[index + 2] = color.b;
                        data[index + 3] = 255;
                    }
                }
                
                // Put the tile on the main canvas
                this.ctx.putImageData(imageData, tileX * this.tileSize, tileY * this.tileSize);
                
                // Cache the tile
                const tileKey = `${tileX},${tileY}`;
                this.tileCache.set(tileKey, imageData);
                
                // Limit cache size
                if (this.tileCache.size > 100) {
                    // Remove oldest entry (simple approach)
                    const firstKey = this.tileCache.keys().next().value;
                    this.tileCache.delete(firstKey);
                }
                
                // Callback to continue rendering
                callback();
            }
            mandelbrot(cx, cy) {
                let x = 0;
                let y = 0;
                let iterations = 0;
                
                while (x * x + y * y <= 4 && iterations < this.maxIterations) {
                    const xTemp = x * x - y * y + cx;
                    y = 2 * x * y + cy;
                    x = xTemp;
                    iterations++;
                }
                
                return iterations;
            }
            getColor(iterations) {
                if (iterations === this.maxIterations) {
                    return { r: 0, g: 0, b: 0 };
                }
                
                const t = iterations / this.maxIterations;
                
                switch(this.colorScheme) {
                    case 'classic':
                        return {
                            r: Math.floor(9 * (1 - t) * t * t * t * 255),
                            g: Math.floor(15 * (1 - t) * (1 - t) * t * t * 255),
                            b: Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255)
                        };
                    
                    case 'fire':
                        return {
                            r: Math.floor(255 * Math.min(1, t * 2)),
                            g: Math.floor(255 * Math.max(0, t * 2 - 1)),
                            b: Math.floor(255 * Math.max(0, t * 3 - 2))
                        };
                    
                    case 'ocean':
                        return {
                            r: Math.floor(255 * t * 0.3),
                            g: Math.floor(255 * t * 0.7),
                            b: Math.floor(255 * t)
                        };
                    
                    case 'psychedelic':
                        const hue = t * 360;
                        return this.hslToRgb(hue, 100, 50);
                    
                    case 'grayscale':
                        const gray = Math.floor(255 * t);
                        return { r: gray, g: gray, b: gray };
                    
                    default:
                        return { r: 255, g: 255, b: 255 };
                }
            }
            hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
            exportImage() {
                // Disable export button during export
                const exportBtn = document.getElementById('exportBtn');
                exportBtn.disabled = true;
                exportBtn.textContent = 'Exporting...';
                
                // Create a temporary canvas to ensure full quality export
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                
                // Copy the current canvas content
                tempCtx.drawImage(this.canvas, 0, 0);
                
                // Convert to data URL
                const dataURL = tempCanvas.toDataURL('image/png');
                
                // Create download link
                const link = document.createElement('a');
                link.download = `mandelbrot_${Date.now()}.png`;
                link.href = dataURL;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Re-enable export button
                exportBtn.disabled = false;
                exportBtn.textContent = 'Export as Image';
                
                // Show notification
                this.showNotification('Image exported successfully!');
            }
            showNotification(message) {
                this.notification.textContent = message;
                this.notification.classList.add('show');
                
                setTimeout(() => {
                    this.notification.classList.remove('show');
                }, 3000);
            }
            updateInfo() {
                document.getElementById('zoomLevel').textContent = this.zoom.toFixed(2) + 'x';
                document.getElementById('centerCoords').textContent = 
                    `(${this.centerX.toFixed(6)}, ${this.centerY.toFixed(6)})`;
                document.getElementById('iterations').textContent = this.maxIterations;
            }
        }
        // Initialize the explorer when the page loads
        const explorer = new MandelbrotExplorer();
    </script>
</body>
</html>