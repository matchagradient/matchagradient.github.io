<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon.png">
    <script src="/assets/js/script.js" defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Tree Explorer</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
</head>
<body class="fractal-page">
    <nav>
        <div class="nav-container">
            <div class="logo"><a href="/index.html">Mike Wang</a></div>
            <ul class="nav-links external-links">
                <li><a href="/collections.html">Collections</a></li>
            </ul>
        </div>
    </nav>
    
    <div class="interactive-section interactive-section">
        <canvas id="canvas"></canvas>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span>Rendering...</span>
        </div>
        <div class="controls">
            <h2>Fractal Tree Explorer</h2>
            
            <div class="control-group">
                <label for="branchAngle">Branch Angle</label>
                <input type="range" id="branchAngle" class="quality-slider" min="5" max="60" value="25">
                <div class="range-labels">
                    <span>5°</span>
                    <span>60°</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="branchRatio">Branch Length Ratio</label>
                <input type="range" id="branchRatio" class="quality-slider" min="50" max="90" value="70">
                <div class="range-labels">
                    <span>0.5</span>
                    <span>0.9</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="branchCount">Branches per Node</label>
                <input type="range" id="branchCount" class="quality-slider" min="2" max="5" value="2">
                <div class="range-labels">
                    <span>2</span>
                    <span>5</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="recursionDepth">Recursion Depth</label>
                <input type="range" id="recursionDepth" class="quality-slider" min="1" max="12" value="9">
                <div class="range-labels">
                    <span>1</span>
                    <span>12</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="trunkLength">Trunk Length</label>
                <input type="range" id="trunkLength" class="quality-slider" min="50" max="200" value="120">
                <div class="range-labels">
                    <span>50</span>
                    <span>200</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="treeType">Tree Type</label>
                <select id="treeType">
                    <option value="binary">Binary Tree</option>
                    <option value="symmetric">Symmetric Tree</option>
                    <option value="asymmetric">Asymmetric Tree</option>
                    <option value="random">Random Tree</option>
                    <option value="willow">Willow Tree</option>
                    <option value="pine">Pine Tree</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="colorScheme">Color Scheme</label>
                <select id="colorScheme">
                    <option value="natural">Natural</option>
                    <option value="autumn">Autumn</option>
                    <option value="winter">Winter</option>
                    <option value="cherry">Cherry Blossom</option>
                    <option value="psychedelic">Psychedelic</option>
                </select>
            </div>
            
            <div class="direction-controls">
                <div></div>
                <button class="direction-btn" data-direction="up">↑</button>
                <div></div>
                <button class="direction-btn" data-direction="left">←</button>
                <button class="direction-btn center" data-direction="reset">⌂</button>
                <button class="direction-btn" data-direction="right">→</button>
                <div></div>
                <button class="direction-btn" data-direction="down">↓</button>
                <div></div>
            </div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomIn">Zoom In</button>
                <button class="zoom-btn" id="zoomOut">Zoom Out</button>
            </div>
            
            <button class="reset-btn" id="resetView">Reset View</button>
            
            <div class="export-section">
                <button class="export-btn" id="exportBtn">Export as Image</button>
            </div>
            
            <div class="info">
                <div class="info-item">
                    <span class="info-label">Zoom:</span> <span id="zoomLevel">1.0x</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Center:</span> <span id="centerCoords">(0, 0)</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Branches:</span> <span id="branchInfo">2 per node</span>
                </div>
            </div>
        </div>
        <div class="notification" id="notification"></div>
    </div>
    
    <div class="content-section">
        <h1>Exploring Fractal Trees</h1>
        <p>
            Fractal trees are mathematical models that mimic the branching patterns found in nature. 
            Inspired by the research in <span class="highlight">"Branching patterns in nature: from fractals to optimal designs"</span>, 
            this interactive explorer allows you to generate and explore various tree structures based on simple recursive rules.
        </p>
        <p>
            The patterns you see emerge from the mathematical principle of <span class="highlight">self-similarity</span> - 
            where each branch resembles a smaller version of the whole tree. This principle is found throughout nature, 
            from trees and rivers to blood vessels and lightning bolts.
        </p>
        
        <h2>The Science Behind Fractal Trees</h2>
        <p>
            Fractal trees are generated using recursive algorithms that follow simple rules:
        </p>
        <ul style="margin-left: 20px; margin-bottom: 20px; font-size: 18px; line-height: 1.6;">
            <li>Each branch splits into a specific number of child branches</li>
            <li>The angle between branches determines the tree's shape</li>
            <li>The length ratio between parent and child branches affects the overall proportions</li>
            <li>The recursion depth controls how many times the branching process repeats</li>
        </ul>
        <p>
            These parameters can be adjusted to simulate different tree species or create entirely new 
            fantastical forms that don't exist in nature.
        </p>
        
        <h2>Features of the Explorer</h2>
        <div class="feature-grid">
            <div class="feature-card">
                <h3>Customizable Parameters</h3>
                <p>Adjust branch angles, length ratios, and recursion depth to create unique tree structures.</p>
            </div>
            <div class="feature-card">
                <h3>Preset Tree Types</h3>
                <p>Choose from various tree types including binary, symmetric, asymmetric, and species-specific models.</p>
            </div>
            <div class="feature-card">
                <h3>Color Schemes</h3>
                <p>Select different color schemes to represent seasons or artistic interpretations of your fractal trees.</p>
            </div>
            <div class="feature-card">
                <h3>Interactive Navigation</h3>
                <p>Pan and zoom to explore your fractal trees at different scales and perspectives.</p>
            </div>
            <div class="feature-card">
                <h3>Export Functionality</h3>
                <p>Save your favorite fractal tree creations as high-quality images for further use or sharing.</p>
            </div>
            <div class="feature-card">
                <h3>Educational Value</h3>
                <p>Learn about fractal geometry and how simple mathematical rules can create complex natural forms.</p>
            </div>
        </div>
        
        <h2>Applications of Fractal Trees</h2>
        <p>
            Beyond their aesthetic appeal, fractal trees have practical applications in various fields:
        </p>
        <ul style="margin-left: 20px; margin-bottom: 20px; font-size: 18px; line-height: 1.6;">
            <li><span class="highlight">Computer Graphics:</span> Generating realistic vegetation in digital environments</li>
            <li><span class="highlight">Architecture:</span> Designing efficient structural systems that mimic natural forms</li>
            <li><span class="highlight">Biology:</span> Modeling vascular systems, neural networks, and plant growth</li>
            <li><span class="highlight">Engineering:</span> Optimizing fluid dynamics and heat transfer systems</li>
            <li><span class="highlight">Art:</span> Creating generative art that explores the intersection of mathematics and aesthetics</li>
        </ul>
        <p>
            By experimenting with the parameters in this explorer, you're not just creating beautiful images - 
            you're exploring the fundamental principles that govern growth and form in the natural world.
        </p>
    </div>
    
    <script>
        class FractalTreeExplorer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.notification = document.getElementById('notification');
                
                // View parameters
                this.centerX = 0;
                this.centerY = 0;
                this.zoom = 1;
                
                // Tree parameters
                this.branchAngle = 25;
                this.branchRatio = 0.7;
                this.branchCount = 2;
                this.recursionDepth = 9;
                this.trunkLength = 120;
                this.treeType = 'binary';
                this.colorScheme = 'natural';
                
                // Random seed for reproducibility
                this.randomSeed = 12345;
                
                // Interaction state
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                // Interesting locations
                this.interestingLocations = {
                    default: { name: "Default View", x: 0, y: 0, zoom: 1 },
                    detail: { name: "Detail View", x: 0, y: -50, zoom: 2 },
                    overview: { name: "Overview", x: 0, y: 0, zoom: 0.7 }
                };
                
                this.init();
            }
            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.render();
                
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.render();
                });
            }
            resizeCanvas() {
                // Set canvas size to match container
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.startDrag(e));
                this.canvas.addEventListener('mousemove', (e) => this.drag(e));
                this.canvas.addEventListener('mouseup', () => this.endDrag());
                this.canvas.addEventListener('mouseleave', () => this.endDrag());
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.startDrag(e.touches[0]));
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.drag(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', () => this.endDrag());
                
                // Wheel zoom
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoomAt(e.clientX, e.clientY, delta);
                });
                
                // Direction controls
                document.querySelectorAll('.direction-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const direction = btn.dataset.direction;
                        if (direction === 'reset') {
                            this.resetView();
                        } else {
                            this.pan(direction);
                        }
                    });
                });
                
                // Zoom buttons
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 1.5);
                });
                
                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 0.67);
                });
                
                // Reset view
                document.getElementById('resetView').addEventListener('click', () => {
                    this.resetView();
                });
                
                // Tree parameters
                document.getElementById('branchAngle').addEventListener('input', (e) => {
                    this.branchAngle = parseInt(e.target.value);
                    this.render();
                });
                
                document.getElementById('branchRatio').addEventListener('input', (e) => {
                    this.branchRatio = parseInt(e.target.value) / 100;
                    this.render();
                });
                
                document.getElementById('branchCount').addEventListener('input', (e) => {
                    this.branchCount = parseInt(e.target.value);
                    this.render();
                    this.updateInfo();
                });
                
                document.getElementById('recursionDepth').addEventListener('input', (e) => {
                    this.recursionDepth = parseInt(e.target.value);
                    this.render();
                });
                
                document.getElementById('trunkLength').addEventListener('input', (e) => {
                    this.trunkLength = parseInt(e.target.value);
                    this.render();
                });
                
                document.getElementById('treeType').addEventListener('change', (e) => {
                    this.treeType = e.target.value;
                    this.applyTreePreset();
                    this.render();
                });
                
                document.getElementById('colorScheme').addEventListener('change', (e) => {
                    this.colorScheme = e.target.value;
                    this.render();
                });
                
                // Export button
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportImage();
                });
            }
            startDrag(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
            }
            drag(e) {
                if (!this.isDragging) return;
                
                const dx = e.clientX - this.lastX;
                const dy = e.clientY - this.lastY;
                
                const scale = 1 / this.zoom;
                this.centerX += dx * scale;
                this.centerY += dy * scale;
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                this.updateInfo();
                this.render();
            }
            endDrag() {
                this.isDragging = false;
            }
            pan(direction) {
                const moveAmount = 50 / this.zoom;
                
                switch(direction) {
                    case 'up':
                        this.centerY -= moveAmount;
                        break;
                    case 'down':
                        this.centerY += moveAmount;
                        break;
                    case 'left':
                        this.centerX -= moveAmount;
                        break;
                    case 'right':
                        this.centerX += moveAmount;
                        break;
                }
                
                this.updateInfo();
                this.render();
            }
            zoomAt(x, y, factor) {
                const scale = 1 / this.zoom;
                const worldX = this.centerX + (x - this.canvas.width / 2) * scale;
                const worldY = this.centerY + (y - this.canvas.height / 2) * scale;
                
                this.zoom *= factor;
                
                const newScale = 1 / this.zoom;
                this.centerX = worldX - (x - this.canvas.width / 2) * newScale;
                this.centerY = worldY - (y - this.canvas.height / 2) * newScale;
                
                this.updateInfo();
                this.render();
            }
            resetView() {
                this.centerX = 0;
                this.centerY = 0;
                this.zoom = 1;
                this.updateInfo();
                this.render();
            }
            applyTreePreset() {
                // Apply preset parameters based on tree type
                switch(this.treeType) {
                    case 'binary':
                        this.branchAngle = 25;
                        this.branchRatio = 0.7;
                        this.branchCount = 2;
                        this.recursionDepth = 9;
                        this.trunkLength = 120;
                        break;
                    case 'symmetric':
                        this.branchAngle = 30;
                        this.branchRatio = 0.75;
                        this.branchCount = 3;
                        this.recursionDepth = 8;
                        this.trunkLength = 100;
                        break;
                    case 'asymmetric':
                        this.branchAngle = 35;
                        this.branchRatio = 0.65;
                        this.branchCount = 2;
                        this.recursionDepth = 10;
                        this.trunkLength = 140;
                        break;
                    case 'random':
                        this.branchAngle = 40;
                        this.branchRatio = 0.7;
                        this.branchCount = 3;
                        this.recursionDepth = 9;
                        this.trunkLength = 120;
                        // Generate new random seed
                        this.randomSeed = Math.floor(Math.random() * 100000);
                        break;
                    case 'willow':
                        this.branchAngle = 15;
                        this.branchRatio = 0.8;
                        this.branchCount = 4;
                        this.recursionDepth = 11;
                        this.trunkLength = 80;
                        break;
                    case 'pine':
                        this.branchAngle = 45;
                        this.branchRatio = 0.6;
                        this.branchCount = 5;
                        this.recursionDepth = 7;
                        this.trunkLength = 150;
                        break;
                }
                
                // Update UI controls to match new values
                document.getElementById('branchAngle').value = this.branchAngle;
                document.getElementById('branchRatio').value = this.branchRatio * 100;
                document.getElementById('branchCount').value = this.branchCount;
                document.getElementById('recursionDepth').value = this.recursionDepth;
                document.getElementById('trunkLength').value = this.trunkLength;
                
                this.updateInfo();
            }
            render() {
                // Clear the canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Save the current context state
                this.ctx.save();
                
                // Apply transformations
                this.ctx.translate(this.canvas.width / 2 + this.centerX * this.zoom, 
                                  this.canvas.height / 2 + this.centerY * this.zoom);
                this.ctx.scale(this.zoom, this.zoom);
                
                // Draw the tree
                this.drawTree(0, 0, -Math.PI/2, this.trunkLength, this.recursionDepth);
                
                // Restore the context state
                this.ctx.restore();
            }
            drawTree(x, y, angle, length, depth) {
                if (depth === 0) return;
                
                // Calculate end point of the branch
                const endX = x + Math.cos(angle) * length;
                const endY = y + Math.sin(angle) * length;
                
                // Set line properties based on depth
                this.ctx.lineWidth = Math.max(1, depth / 2);
                
                // Set color based on depth and color scheme
                const color = this.getBranchColor(depth, this.recursionDepth);
                this.ctx.strokeStyle = color;
                
                // Draw the branch
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Draw leaves at the end of branches
                if (depth <= 2) {
                    this.drawLeaves(endX, endY, depth);
                }
                
                // Recursively draw child branches
                if (depth > 1) {
                    switch(this.treeType) {
                        case 'binary':
                            this.drawBinaryBranches(endX, endY, angle, length, depth);
                            break;
                        case 'symmetric':
                            this.drawSymmetricBranches(endX, endY, angle, length, depth);
                            break;
                        case 'asymmetric':
                            this.drawAsymmetricBranches(endX, endY, angle, length, depth);
                            break;
                        case 'random':
                            this.drawRandomBranches(endX, endY, angle, length, depth);
                            break;
                        case 'willow':
                            this.drawWillowBranches(endX, endY, angle, length, depth);
                            break;
                        case 'pine':
                            this.drawPineBranches(endX, endY, angle, length, depth);
                            break;
                    }
                }
            }
            drawBinaryBranches(x, y, angle, length, depth) {
                const newLength = length * this.branchRatio;
                const angleRad = this.branchAngle * Math.PI / 180;
                
                // Left branch
                this.drawTree(x, y, angle - angleRad, newLength, depth - 1);
                
                // Right branch
                this.drawTree(x, y, angle + angleRad, newLength, depth - 1);
            }
            drawSymmetricBranches(x, y, angle, length, depth) {
                const newLength = length * this.branchRatio;
                const angleRad = this.branchAngle * Math.PI / 180;
                
                // Calculate angles for symmetric branches
                for (let i = 0; i < this.branchCount; i++) {
                    const branchAngle = angle + (i - (this.branchCount - 1) / 2) * angleRad;
                    this.drawTree(x, y, branchAngle, newLength, depth - 1);
                }
            }
            drawAsymmetricBranches(x, y, angle, length, depth) {
                const newLength = length * this.branchRatio;
                const angleRad = this.branchAngle * Math.PI / 180;
                
                // Left branch (shorter)
                this.drawTree(x, y, angle - angleRad * 1.2, newLength * 0.8, depth - 1);
                
                // Right branch (longer)
                this.drawTree(x, y, angle + angleRad * 0.8, newLength * 1.2, depth - 1);
            }
            drawRandomBranches(x, y, angle, length, depth) {
                const newLength = length * this.branchRatio;
                
                // Use seeded random for reproducibility
                const random = this.seededRandom();
                
                // Draw random number of branches
                const numBranches = Math.floor(random() * 2) + 2;
                
                for (let i = 0; i < numBranches; i++) {
                    const angleVariation = (random() - 0.5) * this.branchAngle * 2 * Math.PI / 180;
                    const lengthVariation = 0.8 + random() * 0.4;
                    
                    this.drawTree(x, y, angle + angleVariation, newLength * lengthVariation, depth - 1);
                }
            }
            drawWillowBranches(x, y, angle, length, depth) {
                const newLength = length * this.branchRatio;
                const angleRad = this.branchAngle * Math.PI / 180;
                
                // Willow branches droop downward
                for (let i = 0; i < this.branchCount; i++) {
                    const branchAngle = angle + (i - (this.branchCount - 1) / 2) * angleRad * 0.5;
                    const droop = depth * 0.05; // More droop at higher depths
                    
                    this.drawTree(x, y, branchAngle + droop, newLength, depth - 1);
                }
            }
            drawPineBranches(x, y, angle, length, depth) {
                const newLength = length * this.branchRatio;
                const angleRad = this.branchAngle * Math.PI / 180;
                
                // Pine branches are more upward pointing
                for (let i = 0; i < this.branchCount; i++) {
                    const branchAngle = angle + (i - (this.branchCount - 1) / 2) * angleRad * 0.7;
                    const upward = depth * -0.03; // Slight upward angle
                    
                    this.drawTree(x, y, branchAngle + upward, newLength, depth - 1);
                }
            }
            drawLeaves(x, y, depth) {
                // Only draw leaves for certain color schemes
                if (this.colorScheme === 'natural' || this.colorScheme === 'autumn' || 
                    this.colorScheme === 'cherry') {
                    
                    const leafSize = 3 + Math.random() * 3;
                    const leafColor = this.getLeafColor(depth);
                    
                    this.ctx.fillStyle = leafColor;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, leafSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            getBranchColor(depth, maxDepth) {
                // Calculate color based on depth and color scheme
                const ratio = depth / maxDepth;
                
                switch(this.colorScheme) {
                    case 'natural':
                        // Brown to green gradient
                        const r = Math.floor(101 + ratio * 30);
                        const g = Math.floor(67 + ratio * 100);
                        const b = Math.floor(33 + ratio * 50);
                        return `rgb(${r}, ${g}, ${b})`;
                    
                    case 'autumn':
                        // Brown to orange/yellow gradient
                        const ar = Math.floor(101 + ratio * 154);
                        const ag = Math.floor(67 + ratio * 100);
                        const ab = Math.floor(33 + ratio * 0);
                        return `rgb(${ar}, ${ag}, ${ab})`;
                    
                    case 'winter':
                        // Gray to white gradient
                        const wr = Math.floor(150 + ratio * 105);
                        const wg = Math.floor(150 + ratio * 105);
                        const wb = Math.floor(150 + ratio * 105);
                        return `rgb(${wr}, ${wg}, ${wb})`;
                    
                    case 'cherry':
                        // Brown to pink gradient
                        const cr = Math.floor(101 + ratio * 154);
                        const cg = Math.floor(67 + ratio * 88);
                        const cb = Math.floor(33 + ratio * 133);
                        return `rgb(${cr}, ${cg}, ${cb})`;
                    
                    case 'psychedelic':
                        // Rainbow gradient based on depth
                        const hue = (depth / maxDepth) * 360;
                        return this.hslToRgbString(hue, 100, 50);
                    
                    default:
                        return '#8B4513'; // Brown
                }
            }
            getLeafColor(depth) {
                switch(this.colorScheme) {
                    case 'natural':
                        // Green leaves
                        return `rgb(${34 + Math.random() * 20}, ${139 + Math.random() * 20}, ${34 + Math.random() * 20})`;
                    
                    case 'autumn':
                        // Orange/yellow leaves
                        return `rgb(${255}, ${140 + Math.random() * 40}, ${0})`;
                    
                    case 'cherry':
                        // Pink leaves
                        return `rgb(${255}, ${182 + Math.random() * 30}, ${193 + Math.random() * 30})`;
                    
                    default:
                        return '#228B22'; // Forest green
                }
            }
            hslToRgbString(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
            }
            seededRandom() {
                // Simple seeded random number generator
                let seed = this.randomSeed;
                return function() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                };
            }
            exportImage() {
                // Disable export button during export
                const exportBtn = document.getElementById('exportBtn');
                exportBtn.disabled = true;
                exportBtn.textContent = 'Exporting...';
                
                // Create a temporary canvas to ensure full quality export
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                
                // Copy the current canvas content
                tempCtx.drawImage(this.canvas, 0, 0);
                
                // Convert to data URL
                const dataURL = tempCanvas.toDataURL('image/png');
                
                // Create download link
                const link = document.createElement('a');
                link.download = `fractal_tree_${this.treeType}_${Date.now()}.png`;
                link.href = dataURL;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Re-enable export button
                exportBtn.disabled = false;
                exportBtn.textContent = 'Export as Image';
                
                // Show notification
                this.showNotification('Image exported successfully!');
            }
            showNotification(message) {
                this.notification.textContent = message;
                this.notification.classList.add('show');
                
                setTimeout(() => {
                    this.notification.classList.remove('show');
                }, 3000);
            }
            updateInfo() {
                document.getElementById('zoomLevel').textContent = this.zoom.toFixed(2) + 'x';
                document.getElementById('centerCoords').textContent = 
                    `(${this.centerX.toFixed(0)}, ${this.centerY.toFixed(0)})`;
                document.getElementById('branchInfo').textContent = `${this.branchCount} per node`;
            }
        }
        // Initialize the explorer when the page loads
        const explorer = new FractalTreeExplorer();
    </script>
</body>
</html>